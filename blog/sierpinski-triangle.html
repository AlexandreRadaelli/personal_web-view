<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <title>Blog Archive | Davide Radaelli</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@600&amp;family=Roboto:ital,wght@0,400;0,600;1,400;1,700&amp;display=swap" rel="stylesheet">
	<link rel="stylesheet" href="style.css">
</head>
<body>

	<main class="grid-container">
		<div class="column-left">
            <h1>Simple Intuitive Explanation on how to Render a Sierpinski Triangle with OpenGL</h1>
            <p>While learning OpenGL over at <a href="https://learnopengl.com/">learnopengl.com</a>, I came across the following images in the comment section.</p>
            <img src="../images/comment.png" alt="Comment of neat Sierpinski triangles">
            <p>The form these figures take is called a sierpinski triangle, and I thought about how I could recreate them. Clearly a simple recursion algorithm was at work.</p>
            <h1>How to draw a Sierpinski triangle</h1>
            <p>It’s a fractal (duh) and to complete an iteration, we must basically replace every triangle with a triforce version of itself.</p>
            <img src="../images/triforce.png" alt="triforce-afy">
            <p>Mathematically, this is equivalent to using the midpoint of each side as the vertices of a new triangle. This leaves us with three triangles, each being a quarter of the area of the original.</p>
            <h1>OpenGL in a Nutshell</h1>
            <p><i>The process of using OpenGL can be summarized as follows:</i></p>
            <p>First, you create an array of 3d vertex data you will use to render a bunch of triangles later on. That data will then be sent to the GPU and run through a pipeline of small, sometimes customizable programs called “shaders”. These programs figure out how to translate the input vertex data into the position and color of the pixels on your screen.</p>
            <p>The two main levers developers can pull are:</p>
            <ul>
                <li>The vertex data we send in</li>
                <li>The code used to run the shaders</li>
            </ul>
            <p>In this case we can safely use standard shaders and focus on the vertex data.</p>
            <h1>The Recursive Function</h1>
            <p>Our goal is to create a function where given the three corners of a triangle and the amount of iteration we wish to perform, it will output an array containing the mesh of triangles that form the fractal.</p>
            <p>But first - let’s set up some classes to simplify our job. I will set up a Point class (with member values x, y and z) and I will also set up a vertex class that will be used as an interface to safely manipulate the final vertex data, with a function addTriangle that will take care of adding a single triangle to the mesh.</p>
            <p>Using these classes, we can implement a recursive function addSierpinski, with the following logic:</p>
            <img src="../images/code.PNG" alt="code">
            <p>We effectively add the mathematical implementation of the sierpinski triangle, followed by some additional logic that allows us to input the amount of recursions we wish to be performed.</p>
            <h1>Final Result</h1>
            <img src="../images/triangle.PNG" alt="final-triangle">
            <h1 style="padding-top: 2em;">Edit 1</h1>
            <p>Refactored Sierpinski function to be 3D</p>
            <img src="../images/sierpinski_pyramid.png" alt="Pyramid" style="max-width: 300px;">
        </div>
		<div class="column-center">
			<ul>
				<li><a href="../index.html">Home</a></li>
				<li><a href="../blog.html">Blog</a></li>
				<li><a href="./">Resume</a></li>
				<li><a href="../newsletter.html">Newsletter</a></li>
			</ul>
		</div>
	</main>
</body>
</html>